using System;
using System.IO;
using Xunit;

namespace Hunspell.Tests;

public class FlagForbiddenNeedAffixTests
{
    private static (string affPath, string dicPath) WriteTempFiles(string affContent, string dicContent)
    {
        var tmp = Path.Combine(Path.GetTempPath(), "hunspell_tests_" + Guid.NewGuid().ToString("N"));
        Directory.CreateDirectory(tmp);
        var affPath = Path.Combine(tmp, "temp.aff");
        var dicPath = Path.Combine(tmp, "temp.dic");
        File.WriteAllText(affPath, affContent);
        File.WriteAllText(dicPath, dicContent);
        return (affPath, dicPath);
    }

    [Theory]
    [InlineData("long")]
    [InlineData("num")]
    [InlineData("utf8")]
    public void ForbiddenWord_AppendedFlagBlocksDerived(string flagType)
    {
        // Build aff/dic content per flag format
        string aff;
        string dic;

        if (flagType == "long")
        {
            aff = string.Join("\n", new[] {
                "FLAG long",
                "FORBIDDENWORD BB",
                "SFX S Y 1",
                "SFX S 0 s/BB ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "bar", "bar/AA" }) + "\n";
        }
        else if (flagType == "num")
        {
            aff = string.Join("\n", new[] {
                "FLAG num",
                "FORBIDDENWORD 42",
                "SFX S Y 1",
                "SFX S 0 s/42 ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "bar", "bar/7" }) + "\n";
        }
        else // utf8
        {
            aff = string.Join("\n", new[] {
                "FLAG UTF-8",
                "FORBIDDENWORD Ü",
                "SFX S Y 1",
                "SFX S 0 s/Ü ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "bar", "bar/A" }) + "\n";
        }

        var (affPath, dicPath) = WriteTempFiles(aff, dic);
        try
        {
            using var sp = new HunspellSpellChecker(affPath, dicPath);

            // base "bar" has two variants: one empty flags and one with non-forbidden flag.
            // When the suffix S is applied to produce "bars", the appended flag will be
            // present on every variant -> Should be treated as forbidden.
            Assert.False(sp.Spell("bars"), $"Expected 'bars' to be rejected (FORBIDDENWORD) for flag format {flagType}");

            // The base forms should still be acceptable as-is
            Assert.True(sp.Spell("bar"), "Base form should remain valid");
        }
        finally
        {
            // cleanup
            try { File.Delete(affPath); } catch { }
            try { File.Delete(dicPath); } catch { }
            try { Directory.Delete(Path.GetDirectoryName(affPath)!, true); } catch { }
        }
    }

    [Theory]
    [InlineData("long")]
    [InlineData("num")]
    [InlineData("utf8")]
    public void NeedAffix_BaseRejected_ButDerivedAllowed(string flagType)
    {
        string aff;
        string dic;

        if (flagType == "long")
        {
            aff = string.Join("\n", new[] {
                "FLAG long",
                "NEEDAFFIX NN",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            dic = string.Join("\n", new[] { "1", "foo/NN" }) + "\n";
        }
        else if (flagType == "num")
        {
            aff = string.Join("\n", new[] {
                "FLAG num",
                "NEEDAFFIX 7",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            dic = string.Join("\n", new[] { "1", "foo/7" }) + "\n";
        }
        else // utf8
        {
            aff = string.Join("\n", new[] {
                "FLAG UTF-8",
                "NEEDAFFIX Ü",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            dic = string.Join("\n", new[] { "1", "foo/Ü" }) + "\n";
        }

        var (affPath, dicPath) = WriteTempFiles(aff, dic);
        try
        {
            using var sp = new HunspellSpellChecker(affPath, dicPath);

            // Base requires affix, so bare base should be rejected
            Assert.False(sp.Spell("foo"), $"Expected base 'foo' to be rejected due to NEEDAFFIX for {flagType}");

            // Derived "foos" should be accepted because it can be generated by affix
            Assert.True(sp.Spell("foos"), $"Expected derived 'foos' to be accepted after affix application for {flagType}");
        }
        finally
        {
            try { File.Delete(affPath); } catch { }
            try { File.Delete(dicPath); } catch { }
            try { Directory.Delete(Path.GetDirectoryName(affPath)!, true); } catch { }
        }
    }

    [Theory]
    [InlineData("long")]
    [InlineData("num")]
    [InlineData("utf8")]
    public void ForbiddenWord_NotAllVariantsForbidden_AllowsDerived(string flagType)
    {
        string aff;
        string dic;

        if (flagType == "long")
        {
            aff = string.Join("\n", new[] {
                "FLAG long",
                "FORBIDDENWORD BB",
                "SFX S Y 1",
                "SFX S 0 s/AA ." // append AA to derived
            }) + "\n";

            // two variants for 'bar': one has BB (forbidden) and one has AA
            dic = string.Join("\n", new[] { "2", "bar/BB", "bar/AA" }) + "\n";
        }
        else if (flagType == "num")
        {
            aff = string.Join("\n", new[] {
                "FLAG num",
                "FORBIDDENWORD 42",
                "SFX S Y 1",
                "SFX S 0 s/7 ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "bar/42", "bar/7" }) + "\n";
        }
        else // utf8
        {
            aff = string.Join("\n", new[] {
                "FLAG UTF-8",
                "FORBIDDENWORD Ü",
                "SFX S Y 1",
                "SFX S 0 s/Å ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "bar/Ü", "bar/Å" }) + "\n";
        }

        var (affPath, dicPath) = WriteTempFiles(aff, dic);
        try
        {
            using var sp = new HunspellSpellChecker(affPath, dicPath);

            // One base variant is forbidden (BB/42/Ü) but another lacks it. After
            // applying the suffix that appends a different token, at least one
            // variant of the derived form will remain non-forbidden — derived allowed.
            Assert.True(sp.Spell("bars"), $"Expected 'bars' to be accepted because not all variants are forbidden for {flagType}");
        }
        finally
        {
            try { File.Delete(affPath); } catch { }
            try { File.Delete(dicPath); } catch { }
            try { Directory.Delete(Path.GetDirectoryName(affPath)!, true); } catch { }
        }
    }

    [Theory]
    [InlineData("long")]
    [InlineData("num")]
    [InlineData("utf8")]
    public void NeedAffix_MixedVariants_BaseAccepted_DerivedAccepted(string flagType)
    {
        string aff;
        string dic;

        if (flagType == "long")
        {
            aff = string.Join("\n", new[] {
                "FLAG long",
                "NEEDAFFIX NN",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            // Two variants: one requires affix (NN), one doesn't.
            dic = string.Join("\n", new[] { "2", "foo/NN", "foo" }) + "\n";
        }
        else if (flagType == "num")
        {
            aff = string.Join("\n", new[] {
                "FLAG num",
                "NEEDAFFIX 7",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "foo/7", "foo" }) + "\n";
        }
        else // utf8
        {
            aff = string.Join("\n", new[] {
                "FLAG UTF-8",
                "NEEDAFFIX Ü",
                "SFX S Y 1",
                "SFX S 0 s/ ."
            }) + "\n";

            dic = string.Join("\n", new[] { "2", "foo/Ü", "foo" }) + "\n";
        }

        var (affPath, dicPath) = WriteTempFiles(aff, dic);
        try
        {
            using var sp = new HunspellSpellChecker(affPath, dicPath);

            // Since one variant doesn't require an affix, the base is allowed
            Assert.True(sp.Spell("foo"), $"Expected 'foo' to be accepted when some variants lack NEEDAFFIX ({flagType})");
            // Derived form should also be allowed
            Assert.True(sp.Spell("foos"), $"Expected 'foos' to be accepted when an affix variant exists ({flagType})");
        }
        finally
        {
            try { File.Delete(affPath); } catch { }
            try { File.Delete(dicPath); } catch { }
            try { Directory.Delete(Path.GetDirectoryName(affPath)!, true); } catch { }
        }
    }

    [Fact]
    public void NeedAffix_CombinedAppendedFlags_HandledCorrectly()
    {
        // This test focuses on numerical flags and combined appended tokens like "214,216".
        string aff = string.Join("\n", new[] {
            "FLAG num",
            "NEEDAFFIX 214",
            "SFX S Y 1",
            "SFX S 0 s/214,216 ." // appends two numeric tokens
        }) + "\n";

        // base 'baz' only has NEEDAFFIX 214
        string dic = string.Join("\n", new[] { "1", "baz/214" }) + "\n";

        var (affPath, dicPath) = WriteTempFiles(aff, dic);
        try
        {
            using var sp = new HunspellSpellChecker(affPath, dicPath);

            // base requires affix -> 'baz' rejected
            Assert.False(sp.Spell("baz"), "Expected base 'baz' to be rejected due to NEEDAFFIX");
            // derived 'bazs' should be accepted (affix applied) --- merged tokens handled
            Assert.True(sp.Spell("bazs"), "Expected derived 'bazs' to be accepted even when appended flags combine");
        }
        finally
        {
            try { File.Delete(affPath); } catch { }
            try { File.Delete(dicPath); } catch { }
            try { Directory.Delete(Path.GetDirectoryName(affPath)!, true); } catch { }
        }
    }
}
